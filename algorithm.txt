/*


	as far as I understand, queues made using the freeRTOS library only allow
	you to access only the first element in the queue. This means that working 
	with such a queue is only viable for a simple FIFO scheduling algorithm.
	Therefore, we don't use the queue provided by freeRTOS. Maybe some other 
	functionality of freeRTOS would be useful
	
	so we would need to have an array-based queue initialized like so: {0, 0, 0, 0}
	if there is a 1 at index 0, we know car A is in the queue, if index 1, then
	car B, and so on


*/


// the algorithm to allow 2 noninteracting cars to pass
// cars being in the queue implies said cars are stopped at the border of the intersection area
// cars being out of the queue implies they are free to continue their movements


- create an array-based queue

- add cars to the queue

- repeat

	- Either do this: check and remove two noninteracting cars are in the queue

		- While i < queueSize - 1, start with i = 0 and repeat

			- While j < queueSize, start with j = i + 1 and repeat
	
				- if cars at index i and index j do not interact while passing the
					intersection area, remove them both from the queue

				- increment j

			- increment i

	- Check for any incoming cars that now need to be added to the queue 





// pseudocode for checking and removing two noninteracting cars in the queue

// e.g: {{ ... }, 0, { ... }, 0} 
// car objects are the { ... } 

for(int i = 0; i < queueSize - 1; i++){

	for(int j = i + 1; j < queueSize; j++){
	
		if(queue[i] != 0 && queue[j] != 0){

			
			if(!areCarsInteracting(queue[i].mergingDirection, queue[j].mergingDirection){

				queue[i] = 0; 		// a 0 in a specific index in the queue means this car is not in the queue
				queue[j] = 0;
		
			}
				

		}
	
	} 

}








